<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring框架简述</title>
      <link href="/2021/12/05/spring%E6%A1%86%E6%9E%B6%E7%AE%80%E8%BF%B0/"/>
      <url>/2021/12/05/spring%E6%A1%86%E6%9E%B6%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ioc-amp-DI以及spring框架概述"><a href="#Ioc-amp-DI以及spring框架概述" class="headerlink" title="Ioc&amp;DI以及spring框架概述"></a>Ioc&amp;DI以及spring框架概述</h1><p><img src="file:///C:\Users\86150\AppData\Local\Temp\ksohtml\wpsB903.tmp.png" alt="img"></p><p><strong>一、</strong>我们首先进行了一下面向对象的回顾，类是实现实现业务的需要，类的定义，与类之间的关联关  系。</p><p><strong>二、</strong>我们通过报表的例子，从最原始的实现，到引入容器，把对象的创建交给容器管理，在容器中，我  们提供获取容器的方法，我们用的是单例模式，单例模式的关键点是什么，首先是定义一个静态的属   性，然后提供一个获取对象实例的方法。单例模式又分为懒汉模式和饿汉模式。区别点是属性中是否 new对象。</p><p><strong>三、</strong>我们继续演化，有了容器，我们要从容器中获取交给容器管理的资源，有一种通用的查找资源的设  计模式，就是JNDI。</p><p><strong>四、</strong>查找资源需要资源定位器，使用起来问题是得知道如何查找。为了进一步优化，我们引出来IoC和</p><p>ID的概念。</p><p><strong>五、</strong>重点理解IoC和DI的概念。什么是IoC:</p><p>(1) 、IoC，Inversion of Control，控制反转，不是一种技术，是一种设计原则，解耦对象之间的依赖关系。</p><p>(2) 、控制，控制什么，控制对象的创建和对象之间的依赖关系的维护。</p><p>(3) 、反转，有反就有正，正是对象的创建和依赖关系是由程序通过new的方式来控制，依赖关系也是由程序来控制，反转是将这种方式交给容器，使用的时候，被动的接收资源。</p><p>什么是ID：</p><p>(1) 、DI，Dependency Injection ，依赖注入，它具体的设计模式，体现了IoC的设计原则。</p><p>(2) 、依赖，是应用程序依赖了IoC容器。</p><p>(3) 、为什么依赖，应用程序需要由IoC容器提供对应所需要的资源。(4)、注入，在容器创建的时候，注入应用程序所需要的资源。</p><p><strong>六、</strong>依赖注入的三种类型，接口注入，构造器注入，setter注入，其中对参数的位置和数量有要求的是构造器注入，流行最广泛的是setter注入。</p><p><strong>七、</strong>Spring框架的简介，Spring的架构图。</p><p><strong>八、</strong>Spring实现我们的例子，先导入jar包，然后编写配置元数据，编写相应的功能，配置元数据有三种方式，</p><p>(1) 、一种为XML，这个需要在beans标签加入对应的XSD标记标签库</p><p>(2) 、一种为基于注解，需要在XML中开启注解扫描，有的同学在网上查资料会看到</p><p>&lt;context:annotation-config /&gt;，它是告诉Spring把@Component、@Resource等这些注解开启， component-scan包括了它的功能。</p><p>(3) 、一种为基于java代码的，目前流行最广泛的是基于注解的，基于java的，是一种编写趋势，后续企业中可能会陆续去使用。</p><h2 id="第二章：Spring的Bean生命周期和组装方式"><a href="#第二章：Spring的Bean生命周期和组装方式" class="headerlink" title="第二章：Spring的Bean生命周期和组装方式"></a>第二章：Spring的Bean生命周期和组装方式</h2><p><img src="file:///C:\Users\86150\AppData\Local\Temp\ksohtml\wpsB904.tmp.png" alt="img"></p><p><strong>一、</strong>介绍Spring   IoC的工作视图，SpringIoC容器帮我们生产可使用的对象，需要两个输入，一个是我们的实体类或POJOs，一个是元数据</p><p><strong>二、</strong>Spring IoC容器的两个核心的接口，一个是BeanFactory一个是ApplicationContext，在实例化的时候，注意对应好具体的实现：</p><p>我们主要介绍了如下实例化方式，BeanFactory的：</p><p>BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(“beans.xml”)); ApplicationContext的</p><p>ApplicationContext ctx = new ClassPathXmlApplicationContext(“beans.xml”);</p><p>ApplicationContext ctx = new FileSystemXmlApplicationContext(“classpath:beans.xml”); 或 者是全路径</p><p>ApplicationContext ctx = new AnnotationConfigApplicationContext(Run.class);</p><p><strong>三、BeanFactory与ApplicationContext的区别</strong></p><p>(1) 、 BeanFactory提供了配置框架和基本功能，ApplicationContext则添加了更多的企业特定功</p><p>能。</p><p>(2) 、ApplicationContext是BeanFactory的一个子接口，同时也是它的一个完整的超集。</p><p>(3) 、实例Bean的载入方式不同：BeanFactory延迟载入所有Bean，直到getBean()方法调用时才被</p><p>创建。ApplicationContext启动后载入所有单实例Bean。通过预载入单实例Bean，确保当需要时可以 使用。</p><p><strong>四、我们讲了Bean的三种实例化方式，</strong></p><p>(1) 、默认使用的是构造方法实例化，调用默认的构造方法。</p><p>(2) 、静态工厂方法实例化，实例对象的方法必须是静态的，不但要通过class属性指定相应的工厂，需要通过factory-method来指定具体的工厂方法。</p><p>(3) 、实例工厂方法实例化，实例工厂，首先得把工厂实例了，然后再实例对象时，class属性必须为空，通过factory-bean来指定工厂，通过factory-method来指定实例方法。</p><p><strong>五、我们还讲了Spring的生命周期，包括四个大的阶段：</strong></p><p>(1)、实例化。(2)、属性赋值。(3)、初始化。</p><p>1&gt;如果Bean实现了BeanNameAware接口，Spring将Bean的Id传递给setBeanName()方法。</p><p>2&gt;如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器传入。</p><p>3&gt;如果Bean实现了ApplicationContextAware接口，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入。</p><p>4&gt;如果Bean实现了BeanPostProcessor接口，Spring就将调用postProcessBeforeInitialization()方法。</p><p>5&gt;如果Bean 实现了InitializingBean接口，Spring将调用afterPropertiesSet()方法。</p><p>方法。</p><p>6&gt;如果bean使用init-method声明了初始化方法，Spring将调用该方法。</p><p>7&gt;如果Bean 实现了BeanPostProcessor接口，Spring就将调用postProcessAfterInitialization()</p><p>8&gt;至此，Bean已经准备就绪，可以被使用了。他们将一直驻留在容器中，直到容器被销毁。</p><p>(4)、销毁。</p><p>1&gt;如果bean实现了DisposableBean接口，Spring将调用destory()方法。  2&gt;如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p><p><strong>六、</strong>我们还讲了Bean的自定义初始化和销毁的三种方法，分别为实现接口，配置XML文件，注解，执行顺序为：注解&gt;实现接口&gt;XML</p><p><strong>七</strong>、我们继续讲了Bean的作用域，默认的是singleton，在XML中通过scope属性来进行配置，在web应用中，是单例和原型两个作用域，singleton与prototype，它们的区别：</p><p>(1) 、在Spring IoC容器中是否存在多个，我们通过输出hashCode来看了一下，设置成prototype确实是不一样的</p><p>(2) 、实例化时机不同，ApplicationContext实例化单例的时候，容器实例化就实例化了，而实例化prototype的时候，是调用getBean()方法的时候实例化。</p><p>(3) 、单例的时候，容器销毁的时候，会销毁对象实例，原型作用域下，不会销毁。</p><p><strong>八、</strong>我们继续讲了Bean的依赖注入，首先是构造方法注入，构造方法有三种方式，分别是使用参数的  类型type，使用参数的顺序index，使用参数名称name，在配置文件中使用的是，如果是注入的值使用的是value，如何注入的是引用类型，使用的是ref</p><p><strong>九</strong>、我们还讲了setter注入，setter注入，首先属性中必须要有setter方法，然后在配置文件中使用</p><p><strong>十、</strong>我们继续讲了基本类型注入，这部分都比较简单，其中内部类需要注意它的默认构造方法，有一个  所属类的参数。</p><p><strong>十一</strong>、我们也讲了集合合并和模板装配，发生在父子里。集合合并通过属性指定merge属性，来进行合并，模板需要设置abstract=true</p><p><strong>十二</strong>、我们重点讲了自动装配，全局配置可以通过在beans标签中增加default-autowire属性指定，如   何不配置全局的，在bean标签中，通过autowire属性进行设置，在全局设置时，整个容器所采用的都是相同类型的自动注入，在bean中的，可以有不同的，它的值一共有四种 ，</p><p>(1)、no，为默认自动装配模式，不自动装配。(2)、byName，通过定义的名字进行装配。(3)、byType，通过类型进行装配。</p><p>(4)、constructor，和byType类似。十三、我们在这里也讲了注解，</p><p>(1) 、@Component，</p><p>(2) 、@Autowired，只能通过类型注入，如果需要通过名称注入，需要通过@Qualifier(“xxx”)方</p><p>式。</p><p>(3) 、@Resource，@Resource有两个参数，一个name，是通过name注入，一个是type，是通过</p><p>类型注入。如果不加参数，默认先找name，找不到再找类型，再找不到抛出异常。</p><p>十四、我们还讲了使用外部属性文件，&lt;context:property-placeholder location=”jdbc.properties”/&gt;，然后使用${bbb}来取值就可以。</p><p>**<br>**</p><h1 id="SpringEL"><a href="#SpringEL" class="headerlink" title="SpringEL"></a>SpringEL</h1><p><img src="file:///C:\Users\86150\AppData\Local\Temp\ksohtml\wpsB905.tmp.png" alt="img"></p><p>一、我们介绍了数据验证的底层实现，我们后期用到的数据验证都是基于这个验证来实现的。  二、我们介绍了SpringEL的底层，表达式解析，可以执行对应的方法。</p><p>三、定义表达式的语法形式：#{&lt;表达式字符串&gt;}</p><p>四、其它的都是些常规操作，大家试练习一下就可以了，没有什么特别需要理解的。这一章节比较简  单，重点记住定义表达式的语法形式。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p><img src="file:///C:\Users\86150\AppData\Local\Temp\ksohtml\wpsB906.tmp.png" alt="img"></p><p>一、代理模式，它解决的核心问题是：使用代理模式创建代理对象，让代理对象控制目标对象的访问，  并且可以在不改变目标对象的情况下添加一些额外的功能。分为静态代理和动态代理。</p><p>(1) 、静态代理，真实的业务类和代理类 ，都实现同一个接口，在代理类中引用真实类，在代理类中调用被代理类的方法，客户端访问的时候，访问代理类。</p><p>(2) 、动态代理，从jdk1.3以后，jdk给我们提供了动态生成代理类的方法，首先要实现InvocationHandler接口，使用Proxy.newProxyInstance()方法来创建代理对象，其中，这个方法有三   个参数，一个是ClassLoader，一个是被代理类的所有接口，一个是它本身。执行业务方法，是重写的Invoke方法。</p><p>二、还讲了一些AOP的概念，这个大家多理解理解，这个没啥好的办法，动手写程序，然后理解其中的概念，实在是理解困难，先记住如何写程序，这也是没办法的办法。AOP是对OOP的补充，而不是替  代，经常和OOP一起使用。典型的例子包括日志、验证、事务管理等，优点是：</p><p>使开发人员集中关注于系统的核心业务逻辑。</p><p>更利于创建松散的、可复用、可扩展的软件系统。</p><p>三、对于一些概念，确实比较难理解的，大家一定要记住通知和切入点，他们分别定义了何地与何时。  四、AOP的通知类型，一共有五种，Spring 实现的AOP没有最终通知，这个大家要记住了。Spring的</p><h3 id="AOP实现，就是基于动态代理的，大家掌握了动态代理，就掌握了AOP"><a href="#AOP实现，就是基于动态代理的，大家掌握了动态代理，就掌握了AOP" class="headerlink" title="AOP实现，就是基于动态代理的，大家掌握了动态代理，就掌握了AOP"></a>AOP实现，就是基于动态代理的，大家掌握了动态代理，就掌握了AOP</h3><p>(1) 、前置通知(Before advice)</p><p>1&gt;SpringAOP实现方式：实现MethodBeforeAdvice 2&gt;XML的方式：&lt;aop:before /&gt;</p><p>3&gt;注解方式：@Before</p><p>(2) 、后置通知(After returning advice)</p><p>1&gt;SpringAOP实现方式：实现AfterReturningAdvice 2&gt;XML的方式：&lt;aop:after-returning /&gt;</p><p>3&gt;注解方式：@AfterReturning</p><p>(3) 、 异 常 通 知 (After throwing advice) 1&gt;SpringAOP实现方式：实现ThrowsAdvice 2&gt;XML的方式：&lt;aop:after-throwing /&gt;</p><p>3&gt;注解方式：@AfterThrowing</p><p>(4) 、最终通知(After finally advice) 1&gt;XML的方式：&lt;aop:after /&gt; 2&gt;注解方式：@After</p><p>(5) 、环绕通知(Around advice)</p><p>1&gt;SpringAOP实现方式：实现MethodInterceptor，实现的方法，MethodInvocation invocation，用来执行目标方法</p><p>2&gt;XML的方式：&lt;aop:around  /&gt;，定义的方法，需要有ProceedingJoinPoint  joinPoint这个参数，用来执行目标方法</p><p>3&gt;注解方式：@Around，定义的方法，需要有ProceedingJoinPoint joinPoint参数，用来执行目标方法。</p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>​        在这两章，我们重点对Spring与SpringMVC的整合，SpringMVC的使用做了讲解，我们来一起复习一下。</p><h3 id="一、什么是MVC"><a href="#一、什么是MVC" class="headerlink" title="一、什么是MVC"></a>一、什么是MVC</h3><p>​        MVC不仅仅是java独有的概念，MVC是一种开发Web应用程序的通用架构，它的核心思想是业务数据抽取同业务数据呈现相分离，程序分层，分工合作，既相互独立，又协同工作。</p><p>​        Model，模型层，业务数据的信息表示，用于提供相应的业务逻辑以及数据访问的功能。通常是多个业务实体的组合。考虑需要给客户展示什么。</p><p>​        View，视图示，为用户提供UI，重点关注数据的呈现，用于页面显示，在java中，提供显示的技术有JSP，是由HTML和JSP标签构成。考虑优美的展示给客户信息</p><p>​        Controller，负责Web应用程序的流程跳转以及业务逻辑的调用，传递数据给视图层用于呈现。考虑调用哪些业务逻辑可以满足数据的显示，如何执行效率更高等。</p><h3 id="二、Spring-MVC-概述"><a href="#二、Spring-MVC-概述" class="headerlink" title="二、Spring MVC 概述"></a>二、Spring MVC 概述</h3><p>​        Spring MVC是基于请求驱动，围绕一个核心的Servlet转发请求到对应的Controller而设计的，我们上学期学习了Servlet，可以做Web应用，也学习了请求，路径，请求参数等等，Spring MVC简单理解，就是对Servlet进行了封装，让开发Web应用程序变的更简单。</p><p>​        既然封装了Servlet，那SpringMVC有什么优点呢，</p><p>​        (1)、是一个典型的教科书式的MVC构架，易学易用。</p><p>​        (2)、提供了清晰的角色划分，比如Controller、validator、handler mapping、view resolver等。</p><p>​        (3)、可重用的业务代码。</p><p>​        (4)、可定制的数据绑定和验证，可定制的视图解决方案。</p><p>​        (5)、提供了一套强大又使用简单的标签库。</p><p>​        (6)、支持Restful风格。</p><h3 id="三、SpringMVC体系结构"><a href="#三、SpringMVC体系结构" class="headerlink" title="三、SpringMVC体系结构"></a>三、SpringMVC体系结构</h3><p>​         (1)、SpringMVC是基于请求驱动的，可以处理所有匹配上的请求，那请求来了，到哪呢，我们学习Servlet的时候，是不是需要在web.xml中配置相应的请求路径，然后匹配到对应的Servlet，那SpringMVC封装了Servlet，底层还是Servlet，所以我们还需要在web.xml中配置相应的信息，就是我们图中看到，根据相应的配置，找到对应的DispatcherServlet，Servlet可以在web.xml配置多个，对应到不同的请求，那DispatcherServlet也可以配置多个。</p><p>​          (2)、我们在web.xml中配置好了DispatcherServlet，那么DispatcherServlet是如何找到对应处理器(类)的，我们之前在学习Servlet的时候，如果写一个登陆，是不是对应一个serlvet，对应一个类，再有一个用户信息，是不是再来一个servlet，一个对应的类配置在xml中，即使使用注解，也是多个servlet，对吧，把路径写到类上进行匹配，那SpringMVC是如何匹配到的具体的处理类的呢，提供了一个HandlerMaping映射类，将请求的URL映射到同名的控制器上，返回一个执行链(preHandler-handler-afterHandler-afterCompletion)，那SpringMVC是如何寻找的呢。</p><p>​          (3)、SpringMVC提供了HandlerAdapter，DispatcherServlet内部使用了HandlerAdapter，根据名字我们看出，这是一个适配模式，在统一的适配器，通过配置调用控制器(Handler)，也就是我们所说的Controller。</p><p>​          (4)、在具体的控制器中，会调用相应的业务方法，执行业务逻辑，最终返回一个ModelAndView给DispatcherServlet，其中包含了视图逻辑名和相应的模型数据信息</p><p>​          (5)、DispatcherServlet通过SpringMVC提供的ViewResolver视图解析器，完成逻辑视图到真实的视图解析过程，如在java中，handler返回的肯定不是一个jsp，应该是一个jsp的名称，是一个字符串，它是如何知道是哪个jsp的呢，就是通过ViewResolver来解析的。</p><p>​          (6)、得到真实的视图后，DispatcherServlet使用个这个视图对象View，对ModelAndView中的模型数据进行渲染。</p><p>​          (7)、最终把数据响应给客户。</p><h3 id="四、Spring-MVC生命周期-执行流程"><a href="#四、Spring-MVC生命周期-执行流程" class="headerlink" title="四、Spring MVC生命周期(执行流程)"></a>四、Spring MVC生命周期(执行流程)</h3><p>​        (1)、客户端发送请求，经过一系列的过滤器和过滤器的代理类，使用过滤器代理类的好处就是可以使用Spring的生命周期，交给Spring去管理 。经过过滤器代理和过滤器后，到达DispatcherServlet。</p><p>​        (2)、DipsatcherServlet根据HandlerMapping查找匹配的Controller，并将结果返回给DispatcherServlet。</p><p>​        (3)、DispatcherSerlvet根据找到的Controller，将客户的请求转发到Controller。</p><p>​        (4)、Controller执行处理后，调用各种业务方法，将处理后的结果绑定到ModelAndView，并返回给DispatcherServlet</p><p>​        (5)、DispatcherServlet根据结果，通过视图解析器ViewResolver将ModelAndView绑定的视图进行解析，并返回给DispatcherSevlet。</p><p>​        (6)、DispatcherServlet调用相应的View模板，解析数据，并渲染相应的数据。</p><p>​        (7)、通过真实的View将视图展示的数据，返回给客户。</p><h3 id="五、前端控制器DispacherServlet"><a href="#五、前端控制器DispacherServlet" class="headerlink" title="五、前端控制器DispacherServlet"></a>五、前端控制器DispacherServlet</h3><p>​        当请求到了DispatcherServlet后，DispatchServlet做了哪些事儿呢：</p><p>​        (1)、寻找 WebApplicationContext，并将 WebApplicationContext作为一个属性绑定到请求里，以便控制器或其他原件在后续中使用。默认会以DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE 键绑定到请求里。</p><p>​        (2)、将本地化解析器绑定到请求里，以便在处理这个请求时，原件可以解析到客户端的地区（为了渲染视图，准备日期等）。</p><p>​        (3)、将主题解析其绑定到请求里，让原件（如视图）决定去使用哪一种主题。</p><p>​        (4)、若指定一个multipart file解析器，会检查这个请求包含multiparts请求。</p><p>​        (5)、寻找合适的 handler。如果找到这个 handler，执行与这个 handler 关联的执行链。</p><p>​        (6)、如果返回一个 model，渲染相对应的视图。</p><p>​        不管这里写了啥，还是执行的咱们之前说的那个图。重点是，第一步，就把容器给绑定了，可以在整个请求里使用容器中的内容。</p><h3 id="六、SpringMVC的组件及作用"><a href="#六、SpringMVC的组件及作用" class="headerlink" title="六、SpringMVC的组件及作用"></a>六、SpringMVC的组件及作用</h3><p>​        (1)、HandlerMapping：将传入请求映射到处理器，找到对应的handler。</p><p>​        (2)、DispacherServlet：详见5</p><p>​        (3)、HandlerAdapter：将处理器包装为适配器，从而支持多种类型的处理器</p><p>​        (4)、LocaleResolver &amp; LocaleContextResolver：解释客户端所在地区和其时区(本地化)，以便提供国际化的视图</p><p>​        (5)、ThemeResolver：解释Web程序可用主题，比如提供个性化布局</p><p>​        (6)、MultipartResolver：解释multi-part请求，比如表单里支持文件上传</p><p>​        (7)、ViewResolver：提供了视图名称和真实视图之间的映射</p><p>​        (8)、View：是真正进行视图渲染，把结果返回给浏览器的</p><h3 id="七、Controller控制器"><a href="#七、Controller控制器" class="headerlink" title="七、Controller控制器"></a>七、Controller控制器</h3><p>​        (1)、客户请求经由前端控制器DispatcherServlet后，分发给后续子控制器Controller</p><p>​        (2)、SpringMVC的Controller会获取用户的输入，访问由服务接口定义的业务逻辑功能，并通过视图将模型数据再响应给用户。</p><h3 id="八、编写一个SpringMVC的HelloWord"><a href="#八、编写一个SpringMVC的HelloWord" class="headerlink" title="八、编写一个SpringMVC的HelloWord"></a>八、编写一个SpringMVC的HelloWord</h3><p>​        (1)、新建立动态网站工程</p><p>​        (2)、导入spring的包到lib下</p><p>​        (3)、在web.xml中配置DispacherServlet，注意配置文件的位置。</p><p>​        (4)、在web.xml配置Spring的监听，用于初始化Spring 容器，注意配置文件的位置及参数名。</p><p>​        (5)、编写springMVC的配置文件，注意只加载被@Controller标识的类。</p><p>​        (6)、编写spring的配置文件，加载除了@Controller的标识的类。</p><p>​        (7)、编写Controller</p><h3 id="九、SpringMVC常用注解及作用"><a href="#九、SpringMVC常用注解及作用" class="headerlink" title="九、SpringMVC常用注解及作用"></a>九、SpringMVC常用注解及作用</h3><p>​        (1)、@RequestMapping：用于映射URL，该注解可以写在类级别上，也可以写在方法级别上，可以使用method参数来限定请求</p><p>​        (2)、@PathVariable： 可以将 URL 中占位符参数绑定到控制器处理方法的入参中</p><p>​        (3)、@RequestParam：将请求参数绑定到方法参法</p><p>​        (4)、@CookieValue：注解允许将方法参数与HTTPcookie 值绑定</p><p>​        (5)、RequestHeader：映射请求头字段属性</p><p>​        (6)、@ResponseBody：此注解用在方法上，用来表示直接将返回数据写到HTTP响应体里</p><p>​        (7)、GetMapping：等价与@RequestMapping(value=”/xxx”,method=RequestMethod.GET)</p><p>​        (8)、PostMapping：等价与@RequestMapping(value=”/xxx”,method=RequestMethod.POST)</p><h3 id="十、拦截器"><a href="#十、拦截器" class="headerlink" title="十、拦截器"></a>十、拦截器</h3><p>​        Spring的handler映射机制包含了handler拦截器。使用handler拦截器，可以在某些的请求中应用的特殊的功能，比如说检查权限、防止表单重复提交等等，handler映射的拦截器必须实现HandlerInterceptor接口，该接口有3个方法：</p><p>​        preHandle(..) 在handler执行前调用。</p><p>​        postHandle(..) 在handler执行后调用。</p><p>​        afterCompletion(..) 在整一个请求完成后调用。</p><p>​        编写完拦截器，要在springMVC中配置拦截器，mvc:interceptors，被拦截的地址和不拦截的地址，配置使用的拦截器bean，要注意bean的位置。拦截器可以配置多个，要注意多个拦截器之间的执行顺序。</p><h3 id="十一、文件上传"><a href="#十一、文件上传" class="headerlink" title="十一、文件上传"></a>十一、文件上传</h3><p>​        spring整合了两个文件上传功能，一个是基于Servlet3.0的，一个是基于Commons FileUpload的。注意所使用的bean以及需要配置的所上传文件大小的参数。</p><h3 id="十二、视图解析"><a href="#十二、视图解析" class="headerlink" title="十二、视图解析"></a>十二、视图解析</h3><p>​        (1)、InternalResourceViewResolver：它定义了前缀、后缀，并和控制器返回的视图名称拼接在一起，并解析为视图对象，它会将模型数据存放到对应的HttpServletRequest中，然后转发到相应的页面视图。</p><p>​        (2)、ResourceBundleViewResolver，它需要有一个配置文件来定义逻辑视图名称和真正View对象的对应关系。</p><h1 id="Spring对JDBC的支持和事务"><a href="#Spring对JDBC的支持和事务" class="headerlink" title="Spring对JDBC的支持和事务"></a>Spring对JDBC的支持和事务</h1><h3 id="一、DAO"><a href="#一、DAO" class="headerlink" title="一、DAO"></a>一、DAO</h3><p>​        Spring中对数据访问对象(DAO)的支持旨在简化Spring与数据访问技术的操作，使JDBC、Hibernate、JPA和JDO等采用统一的方式访问。</p><h3 id="二、-Controller、-Service、-Repository的作用"><a href="#二、-Controller、-Service、-Repository的作用" class="headerlink" title="二、@Controller、@Service、@Repository的作用"></a>二、@Controller、@Service、@Repository的作用</h3><p>​        @Controller注解用于类，标识该类为控制器。</p><p>​        @Service注解用于类，标识该类为服务层。</p><p>​        @Repository注解用于类，标识该类为数据访问层。</p><h3 id="三、DataSource"><a href="#三、DataSource" class="headerlink" title="三、DataSource"></a>三、DataSource</h3><p>​        而DAO的实现依赖于某个持久化源，比如一个基于JDBC的DAO需要一个数据源DataSource，需要配置driverClassName，url，username，password。</p><h3 id="四、JDBCTmplate"><a href="#四、JDBCTmplate" class="headerlink" title="四、JDBCTmplate"></a>四、JDBCTmplate</h3><p>​        JdbcTemplate类是Spring对JDBC支持类库中的核心类，JdbcTemplate负责创建和释放资源，执行SQL语句、存储过程，并通过ResultSet来返回数据。</p><p>​        使用方式：</p><p>​        (1)、XXXDao注入JdbcTemplate，并且给JdbcTemplate注入DataSource。</p><p>​        (2)、XXXDao继承JdbcDaoSupport类，而JdbcDaoSupport类中定义了JdbcTemplate成员变量</p><h3 id="五、Spring整合jdbc的操作"><a href="#五、Spring整合jdbc的操作" class="headerlink" title="五、Spring整合jdbc的操作"></a>五、Spring整合jdbc的操作</h3><p>​        (1)、增、删、改</p><p>​        (2)、新增，并返回自增主键</p><p>​        (3)、批处理bachUpdate</p><p>​        (4)、查询示例：</p><p>​            1&gt;查询一个对象，queryForObject</p><p>​            2&gt;基于RowMapper查询1个Bean对象</p><p>​            3&gt;基于RowMapper查询多个Bean对象</p><p>​            4&gt;基于RowCallBackHandler查询</p><h3 id="六、什么是事务，事务的特性"><a href="#六、什么是事务，事务的特性" class="headerlink" title="六、什么是事务，事务的特性"></a>六、什么是事务，事务的特性</h3><p>​        概念：事务是一组原子操作的工作单元。</p><p>​        对事务的描述(ACID)：</p><p>​            (1)、原子性(Atomic)</p><p>​                事务由一个或多个行为捆绑在一起组成一个单独的工作单元，原子性保证事务中的所有操作要么都发生，要么都不发生。</p><p>​            (2)、一致性(Consistent)</p><p>​                一旦一个事务结束了(不管成功与否)，系统所处的状态和它的业务规则是一致的，也就是说数据应当不会被破坏。</p><p>​            (3)、隔离性(Isolated)</p><p>​                事务应该允许多名用户操作同一个数据，一名用户的操作不会和其他用户的操作相混淆(隔离级别)。</p><p>​            (4)、持久性(Durable)</p><p>​                一旦事务完成，事务的结果应该持久化，用来保证即使系统崩溃也不会破坏事务的结果。</p><h3 id="七、Spring对事务的支持"><a href="#七、Spring对事务的支持" class="headerlink" title="七、Spring对事务的支持"></a>七、Spring对事务的支持</h3><p>​        Spring框架对事务抽象的关键就是PlatformTransactionManager接口中定义的，获取事务的状态，提交、回滚，三个方法。Spring提供了对应的框架的事务管理器实现，如jdbc的DataSourceTransactionManager，hibernate的HibernateTransactionManager等等。</p><p>​        Spring框架提供了编程式事务管理和声明式事务管理。</p><p>​            (1)、编程式事务管理：</p><p>​                1&gt;可以清楚地控制事务的边界。</p><p>​                2&gt;可自行实现事务开始时间、结束时间、撤消操作的时机等。</p><p>​                3&gt;可以实现细粒度的事务控制。</p><p>​            (2)、声明式事务管理：</p><p>​                (1)、好处是事务管理的API不介入程序，最符合一个非侵入型轻量级容器的要求。</p><p>​                (2)、多数情况下事务不需要细粒度控制，因此建议使用。</p><p>​        Spring对事务的支持是通过AOP来实现的。</p><h3 id="八、知识扩展"><a href="#八、知识扩展" class="headerlink" title="八、知识扩展"></a>八、知识扩展</h3><p>​        事务的拦截的异常、不拦截的异常，事务的传播行为，事务的隔离级别</p><h1 id="Spring-Boot概述"><a href="#Spring-Boot概述" class="headerlink" title="Spring Boot概述"></a>Spring Boot概述</h1><h3 id="一、Spring-Boot主要目标"><a href="#一、Spring-Boot主要目标" class="headerlink" title="一、Spring Boot主要目标"></a>一、Spring Boot主要目标</h3><p>​        (1)、为所有的Spring开发者提供一个更快，更广泛接受的入门体验。</p><p>​        (2)、使用开箱即用的配置（极少配置甚至不用配置），但随时可以配置自己所需要的值（即配置都有默认值，同时也可以根据自己的需要配置）。</p><p>​        (3)、提供大量项目中常见的一系列非功能特征（例如嵌入式服务器，安全性，运行状况检查，外部化配置）。</p><p>​        (4)、没有代码生成，也不需要XML配置。</p><h3 id="二、-SpringBootApplication"><a href="#二、-SpringBootApplication" class="headerlink" title="二、@SpringBootApplication"></a>二、@SpringBootApplication</h3><p>​        (1)、启动 Spring 上下文的自动配置。</p><p>​        (2)、扫描被 @Configuration 修饰的配置类。也会扫描 starter 组件的配置类，并启动加载其默认配置。</p><p>​        (3)、在被该注解修饰的类中，可以用 @Bean 注解来配置多个 Bean 。应用启动时，Spring 容器会加载 Bean 并注入到 Spring 容器。</p><h3 id="三、-RestController"><a href="#三、-RestController" class="headerlink" title="三、@RestController"></a>三、@RestController</h3><p>​        是@Controller与@ResponseBody的组合注解</p><h3 id="四、Spring-Boot配置及多环境配置"><a href="#四、Spring-Boot配置及多环境配置" class="headerlink" title="四、Spring Boot配置及多环境配置"></a>四、Spring Boot配置及多环境配置</h3><p>​        文件名为application-{profile}.properties。</p><p>​        默认为 default，会加载 application-default.properties 默认配置文件，没有该文件就会加载 application.properties 应用配置文件。</p><p>​        当properties与yaml配置文件同时存在时，优先使用properties的配置文件。</p><p>​        默认的WEB容器为tomcat，端口号为8080，context-path为 ‘’。</p><h3 id="五、starter组件"><a href="#五、starter组件" class="headerlink" title="五、starter组件"></a>五、starter组件</h3><p>​        官方组件：spring-boot-starter-xxx</p><p>​        非官方组件：xxx-spring-boot-starter</p><h3 id="六、Spring-Boot的自动装配"><a href="#六、Spring-Boot的自动装配" class="headerlink" title="六、Spring Boot的自动装配"></a>六、Spring Boot的自动装配</h3><p>​        (1)、ImportSelector</p><p>​        (2)、SpringBootApplication</p><p>​        (3)、EnableAutoConfiguration</p><p>​        (4)、AutoConfigurationImportSelector下的：getAutoConfigurationEntry、getCandidateConfigurations、loadSpringFactories</p><h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><h3 id="一、-什么是JPA"><a href="#一、-什么是JPA" class="headerlink" title="一、 什么是JPA"></a>一、 什么是JPA</h3><p>​        (1)、JPA是在吸收现有ORM框架的基础上发展而来，易于使用，伸缩性强。总的来说，JPA包括以下3方面的技术：</p><p>​        (2)、ORM映射元数据：支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系。</p><p>​        (3)、API：操作实体对象来执行CRUD操作。</p><p>​        (4)、查询语言：通过面向对象而非面向数据库的查询语言（JPQL）查询数据，避免程序的SQL语句紧密耦合。</p><h3 id="二、JPA相关操作"><a href="#二、JPA相关操作" class="headerlink" title="二、JPA相关操作"></a>二、JPA相关操作</h3><p>​        (1)、所继承的接口</p><p>​        (2)、增删改查操作</p><p>​        (3)、自定义查询操作</p><p>​        (4)、分页、排序、多条件查询</p><p>​        (5)、原生查询</p><p>​        (6)、数据验证</p><h3 id="三、知识扩展"><a href="#三、知识扩展" class="headerlink" title="三、知识扩展"></a>三、知识扩展</h3><p>​        (1)、统一异常处理</p><p>​        (2)、统一返回值，前后端交互json</p><p>​        (3)、记录日志，logback</p><p>​        (4)、MD5加密、无状态登陆，签名token</p><p>​        (5)、自定义注解鉴权</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE简单总结</title>
      <link href="/2021/12/05/JavaEE%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/05/JavaEE%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-线程与多线程（笔试重点）"><a href="#第一章-线程与多线程（笔试重点）" class="headerlink" title="第一章  线程与多线程（笔试重点）"></a>第一章  线程与多线程（笔试重点）</h1><p>并行和并发的不同</p><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h6 id="线程与进程的区别："><a href="#线程与进程的区别：" class="headerlink" title="线程与进程的区别："></a>线程与进程的区别：</h6><p>（一个进程至少有一个线程）</p><table><thead><tr><th align="center">进程</th><th align="center">线程</th></tr></thead><tbody><tr><td align="center">一个应用程序一个进程</td><td align="center">一个进程可以有多个线程</td></tr><tr><td align="center">独立功能的程序</td><td align="center">执行程序的最小单元</td></tr><tr><td align="center">通过多个线程占据系统资源</td><td align="center">占用CPU的基本单位</td></tr><tr><td align="center">进程之间数据状态完全独立</td><td align="center"><u>线程间共享一块内存空间</u></td></tr></tbody></table><h6 id="线程与进程的特点："><a href="#线程与进程的特点：" class="headerlink" title="线程与进程的特点："></a>线程与进程的特点：</h6><p>进程</p><p>  独立性：有自己独立的空间、功能、资源</p><p>  动态性：有自己的生命周期</p><p>  并发性：CPU在某个时间段之内能并发执行</p><p>线程</p><p>  并发性：并发执行速度更快</p><hr><p>main函数被称为入口函数</p><p><u>进程中有且只有一个主线程和main方法</u></p><p>main函数中有子线程，主线程不一定最后执行完</p><h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><p>每一个Java程序都有一个默认的主进程</p><p>当JVM加载代码发现main方法之后，就会立即启动一个线程，这个线程称为主线程</p><p>–如果main方法中没有创建其他的线程，那么当main方法执行完最后一个语句，JVM就会结束Java应用程序——单线程</p><p>–如果main方法中又创建了其他线程，那么JVM就要在主线程和其他线程之间轮流切换，JVM要等程序中所有线程都结束之后才结束程序——多线程</p><p><strong>主线程特点</strong>：是产生其他子线程的线程</p><p>​                         不一定是最后完成执行的线程</p><p><strong>多线程优势</strong>：<u>“同时”执行时人的感觉，在线程之间实际轮换执行</u></p><p>​                         有多个处理器的系统，可以并发运行不同的进程（否则，任何时刻只有一个线程在运行）</p><p>​                          减轻编写交互频繁、涉及面多的程序和困难</p><p>​                          程序的吞吐量会得到改善</p><p><strong>多线程应用场合</strong>：想要同时处理多件事——单线程处理不了，必须使用多线程</p><p>​                                  多个线程分解大任务：用单线程可以做，但是使用多线程可以更快（类似于左右开弓）</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>完整的生命周期包括五种状态：新建、就绪、运行、阻塞和死亡</p><p>新建状态：new,还没有在其上调用start（）方法——只new了，还没做任何方法</p><p>就绪状态：调用了start方法，但是还没有把它选定为运行线程（cpu还没选中它——排队ing）</p><p>运行状态：被选中的线程作为当前线程所处的状态，<strong>也是线程进入运行状态的唯一方法</strong></p><p>等待/阻塞/睡眠状态：阻塞——资源被掠夺     睡眠——调用了sleep方法        线程仍是活的，它是可运行的，当某件事件出现，它可能返回到<u>可运行状态（就绪状态）</u></p><p>死亡状态：当线程的run()方法完成时就认为它死去。线程一旦死亡，就不能复生。 一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常</p><p><img src="D:/Typora/java/tupian/image-20210302154949619.png" alt="image-20210302154949619"></p><p>继承thread,重写run()方法</p><h2 id="Java中创建线程"><a href="#Java中创建线程" class="headerlink" title="Java中创建线程"></a>Java中创建线程</h2><p>继承Thread类</p><p>1&gt;重写run()方法</p><p>2&gt;new一个线程对象</p><p>3&gt;调用对象的start()启动线程</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com_omest<span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">package</span> com_omest<span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//主线程</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//可以创建子线程</span>        MyThread mythread<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新建//子线程</span>        mythread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//就绪</span>          <span class="token comment" spellcheck="true">//1>mythread.run();这儿是普通方法，会顺序执行，不会创建子线程</span>            <span class="token comment" spellcheck="true">//即hello java</span>            <span class="token comment" spellcheck="true">//1 2 3 4 5</span>            <span class="token comment" spellcheck="true">//aaaaaaaa</span>    <span class="token comment" spellcheck="true">//重点  //2>mythread.start();用两次start方法，会报错</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aaaaaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aaaaaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aaaaaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aaaaaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aaaaaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aaaaaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先主后子</span>                                     <span class="token comment" spellcheck="true">//aaaaa</span>                                     <span class="token comment" spellcheck="true">//aaaaaa</span>                                     <span class="token comment" spellcheck="true">//aaaaaa</span>                                     <span class="token comment" spellcheck="true">//1 2 3 4 5</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>实现Runnable接口</p><p>1&gt;实现run()方法</p><p>2&gt;创建一个Runnable类的对象r，new MyRunnable()</p><p>3&gt;创建Thread类对象并将Runnable对象作为参数，new Thread(r)</p><p>4&gt;调用Thread对象的strat()启动线程</p><h3 id="线程创建的问题"><a href="#线程创建的问题" class="headerlink" title="线程创建的问题"></a>线程创建的问题</h3><p>1&gt;一个线程的run方法执行结束后，该线程结束</p><p>2&gt;一个线程只能被启动一次</p><p>3&gt;在一个CPU的机器上，一次只能运行一个线程</p><p>程序与进程的区别：程序是静态的，进程是动态的</p><p>并发：只有一个cpu有多个任务，在一段时间内，线程有交换</p><p>并行：有多个CPU，在同一个时刻，有多个任务在执行</p><h3 id="线程中常用方法"><a href="#线程中常用方法" class="headerlink" title="线程中常用方法"></a>线程中常用方法</h3><p>•start():启动线程，让线程从新建状态进入就绪队列排队</p><p>•run():线程对象被调度之后所执行的操作</p><p>•sleep():暂停线程的执行，让当前线程休眠若干毫秒</p><p>•currentThread():返回对当前正在执行的线程对象的引用</p><p>•isAlive():测试线程的状态，新建、死亡状态的线程返回false</p><p>•interrupt():“吵醒”休眠的线程，唤醒“自己”</p><p>•yield():暂停正在执行的线程，让同等优先级的线程运行</p><p>•join():当前线程等待调用该方法的线程结束后，再排队等待CPU资源</p><p>•stop():终止线程</p><p>阻塞线程的方法：线程睡眠、线程等待、线层阻塞</p><h3 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h3><p>•Java中通过Thread的静态方法sleep来实现线程的睡眠。当线程睡眠时，它暂停执行，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到<strong>可运行****状态</strong></p><p>•使用场景：</p><p>–线程执行太快</p><p>–需要强制设定为下一轮执行</p><p>•实现方法：在run方法中加入代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>用1~10表示</p><p>–通过Thread实例调用setPriority()方法设置线程优先级</p><p>•Thread.MIN_PRIORITY    (1)</p><p>•Thread.NORM_PRIORITY  (5)</p><p>•Thread.MAX_PRIORITY   (10)</p><p>优先级越大，获取到CPU的可能性越大</p><p>•当线程池中线程都具有相同的优先级，调度程序的操作有两种可能：</p><p>–一是选择一个线程运行，直到它阻塞或者运行完成为止</p><p>–二是时间分片，为池内的每个线程提供均等的运行机会</p><p>•线程让步通过yield方法来实现，暂停当前正在执行的线程对象，并执行<strong>同等优先级</strong>的其他线程</p><p>–yield()将导致线程从运行状态转到可运行状态，有可能没有效果无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中</p><h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><p>•在线程A中调用B.join()。让一个线程A“加入”到线程B的尾部。在B执行完毕之前，A不能工作</p><p>join()方法还有带超时限制的重载版本</p><h3 id="线程离开运行状态的方法"><a href="#线程离开运行状态的方法" class="headerlink" title="线程离开运行状态的方法"></a>线程离开运行状态的方法</h3><p>–调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）</p><p>–调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行</p><p>–调用join()方法：保证当前线程停止执行，直到调用join方法的线程完成为止。然而，如果调用join的线程没有存活，则当前线程不需要停止</p><p>–线程的run()方法完成</p><p>–在对象上调用wait()方法（不是在线程上调用）</p><p>–线程不能在对象上获得锁定，它正试图运行该对象的方法代码</p><p>–线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>•多线程会带来线程调度、同步、死锁等一系列的问题</p><p>资源同步——对象互斥锁</p><p>•Java中每个对象都对应一个称为“互斥锁”的标记</p><p>–关键字synchronized 与对象互斥锁联合起来使用保证对象在任意时刻只能由一个线程访问</p><p>–<strong>synchronized可以修饰方法，表示这个方法在任意时刻只能由一个线程访问</strong></p><p>–synchronized可以修饰类，则表明该类的所有对象共用一把锁</p><p><strong>当多个线程共享一个资源的时候需要进行同步****，</strong></p><p><strong>但是****过多的同步可能导致死锁</strong></p><p>范围越小越好，越精确越好</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>•产生死锁的必要条件</p><p>–互斥条件：指线程对所分配到的资源进行排它性使用</p><p>–请求和保持条件：指线程已经保持至少一个资源，但又提出了新的资源请求</p><p>–不可剥夺条件：进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</p><p>–环路等待条件:指在发生死锁时，必然存在一个线程—资源的环形链</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sleep（）中传入时间的单位是<strong>毫秒</strong></p><p>什么情况下出现死锁：</p><p>不需任何理由就能从运行状态回到就绪状态：JVM调度</p><p>线程生命周期结束（死亡状态）：正常执行完run()方法、或存在异常</p><img src="D:/Typora/java/assets/8EFAE897-55D1-464e-8408-3DE82B71BD62.png" alt="8EFAE897-55D1-464e-8408-3DE82B71BD62" style="zoom:50%;" /><h1 id="第二章-网络编程"><a href="#第二章-网络编程" class="headerlink" title="第二章 网络编程"></a>第二章 网络编程</h1><p>网络编程基础</p><p>根据规模和范围划分为：局域网、城域网、广域网</p><p>IP地址占32位</p><p>IP地址的作用：标识网络中的一个通信实体</p><p>因特网属于广域网</p><p>一个应用程序不是只能占用一个应用端口</p><p>一个端口只能被一个应用程序占用</p><p>发邮件的端口是25，收邮件的端口是110</p><p>HTTP端口80 ，HTTPS端口443</p><p>本机的IP地址：127.0.0.1  对应的域名：localhost</p><p>Tomcat端口：8080   MySql:3306</p><p>IO流分为：输入流和输出流</p><p> 输出流按照内容：字符流和字节流</p><p>TCP/IP基本概念</p><p>–<strong>TCP传输控制协议，是一种面向连接</strong>的、可靠的、基于字节流的传输层通信协议</p><p>•需要首先在网络两端建立安全连接，再进行数据传递，确保网络双方完整无误地传输数据</p><p>–<strong>UDP用户数据报协议，是一种无连接</strong>的传输层协议，提供面向事务的简单不可靠信息传送服务</p><p>•无需建立网络双方连接，直接发送数据包（包含目的地址信息），可能会因为网络问题导致数据传输失败等问题，但是<strong>传输速度很快</strong>，常用于局域网中传输数据</p><h2 id="URL及应用"><a href="#URL及应用" class="headerlink" title="URL及应用"></a>URL及应用</h2><p>作用：将其做成一个工具类，去发送请求，得到响应。或者是向对应的资源中去post一些信息，去修改对应资源的一些信息</p><p>使用Socket进行网络编程</p><p>•URL类：统一资源定位符，指向互联网“资源”的指针</p><p>–常用构造方法：</p><p>​            •URL(String url);  // 通过给定字符串建立URL对象</p><p>–常用方法：</p><p>​            •InputStream openStream(); // 打开当前URL连接的输入流</p><p>​            •URLConnection openConnection();  // 建立URL网络连接</p><p>•URLConnection类：应用程序和 URL 之间的通信链接，用于读取和写入此 URL 引用的资源</p><p>​           –常用方法：</p><p>​                     •获得响应消息头类方法：getContentType()、getContentLength()、getContentEncoding()、……</p><p>​                     •获得响应消息主体：getContent()</p><p>​                     •获得当前连接输入/输出流对象：getInputStream()、getOutputStream()</p><h6 id="1》"><a href="#1》" class="headerlink" title="1》"></a>1》</h6><p>//从网上得到一张图片并把它存储到本地</p><p>步骤：1.从网上找到图片的地址——字符串类型</p><p>​            2.获取图片的URL对象</p><p>​            3.通过URL对象，获取资源的链接（应用URLConnection的openConnection方法）</p><p>​            4.得到链接的输入流</p><p>​            5.IO流相关的输出流</p><p>​            6.循环读写</p><p>​            7.关闭流</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>onest<span class="token punctuation">.</span>net<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>File<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>MalformedURLException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLConnection<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">URLDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从网上得到一张图片并把它存储到本地</span>        <span class="token comment" spellcheck="true">//1.从网上找到图片的地址——字符串类型</span>        String str<span class="token operator">=</span><span class="token string">"https://image.baidu.com/search/detail?"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2.获取URL对象</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            URL url<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//3.通过URL对象，得到资源的链接</span>            URLConnection connection<span class="token operator">=</span>url<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//4.得到链接的输入流</span>            InputStream is<span class="token operator">=</span>connection<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//5.IO流相关存储操作</span>            OutputStream os<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:\\\\DaXue\\\\DaTwoXia\\\\java\\\\tupian"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当最后文件不足1024个字节时，来确定到底读多少字节</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token operator">=</span>is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//os.write(b);有问题，因为最后不一定是读到1024</span>                os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//6.关闭流</span>            is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MalformedURLException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>•HttpURLConnection类：特定支持HTTP协议的URLConnection</p><p>​        –对象建立方法：</p><p>​                   •通过URL对象的openConnection()方法创建，<u>强制转换为目标对象</u></p><p>​                   •使用构造方法：HttpURLConnection( URL url)</p><h6 id="2》"><a href="#2》" class="headerlink" title="2》"></a>2》</h6><p>//文件下载</p><p>步骤：1.创建URL对象：URL url=new URL(文件地址)</p><p>​            2.获取服务端输入流：InputStream is=url.openStream()</p><p>​            3.文件读写：从输入流中读取字节写入到输出流（文件）中</p><pre class=" language-java"><code class="language-java">String sUrl <span class="token operator">=</span> <span class="token string">"http://pic42.nipic.com/20140608/12504116_194242259000_2.jpg"</span><span class="token punctuation">;</span>URL url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>sUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建URL对象</span>InputStream in <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获得网络输入流</span><span class="token comment" spellcheck="true">// 创建文件输出流</span>FileOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>“cat<span class="token punctuation">.</span>jpg"<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入文件</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 关闭输入输出流</span>out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3》</p><p>//获取响应信息</p><pre class=" language-java"><code class="language-java">URL url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>rootUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  创建Url对象</span><span class="token comment" spellcheck="true">// 得到URLConnection连接对象</span>URLConnection conn <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>HttpURLConnection hc <span class="token operator">=</span> <span class="token punctuation">(</span>HttpURLConnection<span class="token punctuation">)</span> conn<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获得响应消息头</span>conn<span class="token punctuation">.</span><span class="token function">getContentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">getContentLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">getContentEncoding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获得HTTP消息状态码</span>hc<span class="token punctuation">.</span><span class="token function">getResponseCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//HttpURLConnection的方法</span>hc<span class="token punctuation">.</span><span class="token function">getResponseMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//HttpURLConnection的方法</span><span class="token comment" spellcheck="true">// 获得HTTP响应消息主体</span>hc<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//urlConnection中定义的方法</span></code></pre><h2 id="Socket网络编程"><a href="#Socket网络编程" class="headerlink" title="Socket网络编程"></a>Socket网络编程</h2><p>客户端和服务器端是靠什么进行区分的：在两端没建立链接，谁作为请求的发出方，即为客户端；被动接收（或对请求进行处理）的一端为服务器端。</p><p>•客户端和服务器端建立连接后，连接两端将会建立一个虚拟“线缆”，在网络编程中称之为Socket（套接字）；其后在网络两端传输数据都是通过Socket进行的</p><p>Socket作用：①连接Client和Server两端</p><p>​                        ②连接之后维持链接在Client和Server两端进行数据的交换</p><p>​           –Socket借助IP地址和端口号，对应某一台主机中的某一个应用程序</p><p>​           –Socket的主要作用是维护网络连接、在网络双方传输数据</p><p>–构造方法：</p><p>​           •Socket(InetAddress address, int port);</p><p>​           •Socket(String host, int port); </p><p>–常用方法：</p><p>​            •getInputStream(); // 获得网络输入流</p><p>​            •getOutputStream(); // 获得网络输出流</p><p>​            •close(); // 关闭Socket连接</p><h2 id="C-S模式应用程序"><a href="#C-S模式应用程序" class="headerlink" title="C/S模式应用程序"></a>C/S模式应用程序</h2><p>•在网络编程中，C/S模式应用程序的开发，需要同时开发客户端应用程序和服务器端应用程序</p><p>​    –客户端应用程序开发步骤：</p><p>​                    •客户端建立与服务器端的连接（通过IP地址和端口确定服务器端程序）//得到Socket对象</p><p>​                    •客户端封装请求数据，发送给服务器端；客户端获得服务器端响应数据，解析并处理数据</p><p>​                    •客户端关闭网络连接//关闭Socket</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>onest<span class="token punctuation">.</span>socketTcp<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//1.根据IP地址和端口确定服务器唯一的应用程序</span>            Socket socket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2.获取输出流发送数据</span>            OutputStream os<span class="token operator">=</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello server"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//getBytes()转成二进制</span>            <span class="token comment" spellcheck="true">//3.获取输入流得到数据进行解析</span>            InputStream is<span class="token operator">=</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//4.关闭流和Socket</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>onest<span class="token punctuation">.</span>socketTcp<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ServerSocket<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//先开启服务器端，在开启客户端</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//1.创建serverSocket对象</span>            ServerSocket serverSocket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此处端口要与客户端口进行对应</span>            <span class="token comment" spellcheck="true">//2.调用accept()方法获取客户端的socket对象</span>            Socket s<span class="token operator">=</span>serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//3.进行网络数据的传输</span>            InputStream is<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            OutputStream os<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello client"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//4.关闭流</span>            is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            serverSocket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>尽量使用6000以后的端口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>onest<span class="token punctuation">.</span>socketTcp1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedWriter<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStreamWriter<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//1.根据IP地址和端口确定服务器唯一的应用程序</span>            Socket socket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2.获取输出流发送数据</span>            Scanner scanner<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>            BufferedWriter writer<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断scanner是否含有对应内容</span>                String  str<span class="token operator">=</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用变量接收其下一行内容</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>                writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>                writer<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//4.关闭流和Socket</span>            writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>onest<span class="token punctuation">.</span>socketTcp1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ServerSocket<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//先开启服务器端，在开启客户端</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//1.创建serverSocket对象</span>            ServerSocket serverSocket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此处端口要与客户端口进行对应</span>            <span class="token comment" spellcheck="true">//2.调用accept()方法获取客户端的socket对象</span>            Socket s<span class="token operator">=</span>serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//3.进行网络数据的传输</span>            BufferedReader reader<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String str<span class="token operator">=</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//4.关闭流</span>            reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            serverSocket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h1 id="第四章-Servlet模型（一）"><a href="#第四章-Servlet模型（一）" class="headerlink" title="第四章   Servlet模型（一）"></a>第四章   Servlet模型（一）</h1><p>相应习题链接：<a href="https://blog.csdn.net/weixin_30568715/article/details/99021999">https://blog.csdn.net/weixin_30568715/article/details/99021999</a></p><p>要对类加锁</p><p>每一个线程对象之间都是相互独立的，用第一种方法</p><p>用字符流</p><p>•webapps：Web项目（站点）目录（将项目文件放在这里，再点击bin中的startup）</p><p><img src="D:/Typora/java/tupian/image-20210406142606089.png" alt="image-20210406142606089"></p><p><img src="D:/Typora/java/tupian/image-20210406143836327.png" alt="image-20210406143836327"></p><p>localhost:8080/项目名/url-pattern</p><p>get方法：获取数据；数据量小；安全性低</p><p>post方法：对服务器中的数据进行修改；数字量没有限制；安全性高</p><p>快捷键：Alt+/</p><p>S</p><p><img src="D:/Typora/java/tupian/image-20210406155117219.png" alt="image-20210406155117219"></p><h4 id="URL到Servlet的映射"><a href="#URL到Servlet的映射" class="headerlink" title="URL到Servlet的映射"></a>URL到Servlet的映射</h4><p>•<url-pattern>标签的匹配方式</p><p>​           –“完整URL”：如“/HelloServlet”</p><p>​           –“/目录/*”方式：以“/目录”做为开头的URL</p><p>​           –“*.ext”：以.ext结尾的地址</p><p>500服务器端错误</p><p>404找不到的问题</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WebApp_ID<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>Ch03_Servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.htm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>default.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>default.htm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>default.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>servlet.MyServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>aaa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>servlet.MyServlet2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>aaa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 第一种方式  完整的URL   第二种方式 以什么开头            第三种方式 以什么结尾--></span><span class="token comment" spellcheck="true">&lt;!--     &lt;url-pattern>/hello2&lt;/url-pattern>--></span>  <span class="token comment" spellcheck="true">&lt;!--    &lt;url-pattern>/hehe/*&lt;/url-pattern>--></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>*.do<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span></code></pre><p>find:ctrl+F</p><p>查看源码:ctrl</p><p><img src="D:/Typora/java/tupian/image-20210406161910868.png" alt="image-20210406161910868"></p><p>servlet的项目部署（将自己在eclipse中的项目部署到web中）</p><p><img src="D:/Typora/java/tupian/image-20210406164420606.png" alt="image-20210406164420606"></p><p><img src="D:/Typora/java/tupian/image-20210406164457318.png" alt="image-20210406164457318"></p><p>课程要求：</p><p>1.自己实现MyServlet两种方式</p><p>2.servlet    ——web.xml的部署配置</p><p>​    共三种方式：完全、前限、后限</p><p>3.servlet  访问过程   请求响应</p><p>4.servlet的项目部署（将自己在eclipse中的项目部署到web中）</p><p>   两种方式①手动</p><p>​                   ②webapps-&gt;webapps</p><p>5.get和post的区别</p><p>创建动态的web项目</p><p><img src="D:/Typora/java/tupian/image-20210413140645620.png" alt="image-20210413140645620"></p><p><img src="D:/Typora/java/tupian/image-20210413140801600.png" alt="image-20210413140801600"></p><p><img src="D:/Typora/java/tupian/image-20210413140858717.png" alt="image-20210413140858717"></p><p><img src="D:/Typora/java/assets/image-20210413141106771.png" alt="image-20210413141106771"></p><p>rus as -》1</p><p>Alt+/  快捷键doGet</p><p>看工作空间</p><p>（右击项目，点击properties）</p><p><img src="D:/Typora/java/tupian/image-20210413144422549.png" alt="image-20210413144422549"></p><p><img src="D:/Typora/java/tupian/image-20210413144702952.png" alt="image-20210413144702952"></p><p>servlet 接口</p><p>GemericServlet 抽象类            service()</p><p>HttpServlet -——get doGet         post doPost</p><p>MyServlet</p><p>getParameter</p><p>setAttribute 和getAttribute</p><p>重定向会改变地址栏</p><p>请求不会改变地址栏</p><p><u><strong>生命周期中init()和destroy()方法只执行一次</strong></u></p><p><u><strong>service()调用几次执行几次</strong></u></p><p>一个servlet容器中只会有一个对象</p><p>•Servlet的生命周期可以分为四个阶段</p><p>–加载和实例化：由Servlet容器完成</p><p>–初始化：实例化Servlet后会调用init方法</p><p>–服务：service方法(doGet或doPost)</p><p>–销毁：销毁之前会调用destroy方法</p><p><img src="D:/Typora/java/tupian/image-20210413170137937.png" alt="image-20210413170137937"></p><p><img src="D:/Typora/java/tupian/image-20210413170152248.png" alt="image-20210413170152248"></p><h1 id="第五章-Servlet模型（二）"><a href="#第五章-Servlet模型（二）" class="headerlink" title="第五章  Servlet模型（二）"></a>第五章  Servlet模型（二）</h1><p>Servlet生命周期总结</p><p>•Servlet的生命周期可以分为四个阶段</p><p>–加载和实例化：由Servlet容器完成</p><p>–初始化：实例化Servlet后会调用init方法</p><p>–服务：service方法(doGet或doPost)</p><p>–销毁：销毁之前会调用destroy方法</p><p>Servlet是多线程应用，非线程安全</p><p>容器生成request和response对象</p><p>response可以返回数据也可以返回页面</p><p>请求转发和请求重定向:请求转发只发送了一次请求，请求重定向发了两次请求（两次请求对象不同）</p><p>请求转发显示一个URL，请求重定向只显示最后一次的URL</p><h2 id="Servlet应用进阶"><a href="#Servlet应用进阶" class="headerlink" title="Servlet应用进阶"></a>Servlet应用进阶</h2><h4 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h4><p>•ServletConfig是由Servlet容器实例化</p><p>–Servlet实例化的同时实例化对应的ServletConfig对象，并传入到init(ServletConfig config)</p><!--如果在自己的servlet中重写了init()方法，则不能得到ServletConfig对象--><p>•数据共享的方式</p><p>共四种方法</p><p><img src="D:/Typora/java/tupian/image-20210420150958803.png" alt="image-20210420150958803"></p><p>在第一个Servlet中设置，在第二个Servlet中就可以获取</p><p>loadOnStarup=1表示一启动就实例化对象</p><p>按F12 查看相应的请求响应对象</p><h1 id="任务二小知识-Servlet模型"><a href="#任务二小知识-Servlet模型" class="headerlink" title="任务二小知识  Servlet模型"></a>任务二小知识  Servlet模型</h1><p>==1.==动态网页的特点：交互性、自动更新、随机性</p><p>==2.==B/S框架的工作流程：浏览器接受用户的输入–&gt;浏览器向服务端发送请求–&gt;服务器端数据处理–&gt;响应数据至客户端</p><p>==3.==正确格式的URL：<a href="http://localhost:8080/news/index.jsp">http://localhost:8080/news/index.jsp</a></p><p>==4.==Servlet生命周期的说法：</p><p>①Servlet容器根据Servlet类的位置加载Servlet类，成功加载后，由容器创建Servlet的实例</p><p>②对于每一个Servlet实例，init()方法只被调用一次；</p><p>在Servlet实例化之后，调用Service之前调用init()方法。</p><h2 id="Servlet生命周期中的方法"><a href="#Servlet生命周期中的方法" class="headerlink" title="Servlet生命周期中的方法"></a>Servlet生命周期中的方法</h2><table><thead><tr><th><strong>方法</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>init()</td><td>在Servlet实例化之后，调用Service之前调用init()方法</td></tr><tr><td>service()</td><td>调用此方法允许Servlet响应请求，在Servlet成功初始化之前无法调用</td></tr><tr><td>destroy()</td><td>当一个Servlet被从服务中去除时，Servlet容器会调用此方法。在这个对象service()方法所有的线程未全部退出或者没有被容器认为发生超时操作时，此方法不会调用</td></tr><tr><td>getServletConfig()</td><td></td></tr><tr><td>getServletInfo()</td><td></td></tr></tbody></table><p>③当Servlet容器接收到客户端请求时，调用Service()方法处理客户端请求</p><p>④servlet的实例是由servlet容器创建的，所以实例销毁也由容器完成</p><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>具体为：</p><p>​        1 Servlet的生命周期是通过Servlet接口中的init(),service(),和destroy()方法来表示的，即Servlet从创建到销毁的过程。包括如何加载和实例化，初始化，处理请求，以及如何销毁。</p><p>（1）Servlet容器Servlet类的位置加载Servlet类，成功加载后，由容器创建实例。</p><p>其中xml中<load-on-startup></load-on-startup>可以控制生成时间</p><p>（2）初始化，在Servlet容器完成实例化后,Servlet容器将调用Servlet的init（）方法进行初始化，初始化的目的是让Servlet对象在处理客户端请求前完成一些初始化工作，如，设置数据库连接参数，建立JDBC连接，或者是对其他资源的引用。（对于每一个Servlet实例，init（）方法只被调用一次）</p><p>（3）服务，Srevlet被初始化后，就处于能响应请求的就绪状态。当Servlet容器接收客户端请求时，调用Srevlet的service（）方法处理客户端请求</p><p> public void service(ServletRequest req, ServletResponse res)<br>    throws ServletException, IOException<br>  {<br>    HttpServletRequest request;<br>    HttpServletResponse response;</p><pre><code>if (!(req instanceof HttpServletRequest &amp;&amp;    res instanceof HttpServletResponse)) &#123;  throw new ServletException(&quot;non-HTTP request or response&quot;);&#125;</code></pre><p>​    request = (HttpServletRequest) req;<br>​    response = (HttpServletResponse) res;</p><p>​    service(request, response);<br>  }。</p><p>相当一个分发器，可以根据请求方法的类型，调用相应的doXxx()方法。所以在编写Servlet时只需要根据应用的需求，重写daoGe（）t或者doPost（）方法即可。</p><p>（4）销毁，<u>Servlet的实例是由Servlet容器创建的，所以实例的销毁也是由容器来完成的。</u>Servlet容器判断一个Servlet是否应当被释放时，容器关闭，回收资源。容器就会调用Servlet的destroy（）方法，该方法指明哪些资源可以被系统回收，而不是由destroy（）方法直接进行回收。</p><p>​           2 Servlet是一个java程序，它运行在服务器端，接收和处理客户端用户请求，并做出响应。</p><p>​           3 xxx.jsp在运行时首先解析成一个Java类xxx_jsp.java该类继承于HttpJspBase类，HttpJspBase类又是继承自HttpServlet的类，可以得出一个结论，JSP在运行时会被Web容器翻译成一个Servlet。</p><p>==5.==可以正确设置客户端请求编码为UTF-8的是：</p><p>request.setCharacterEncoding(“UTF-8”)</p><h2 id="Servlet中的几个方法的作用"><a href="#Servlet中的几个方法的作用" class="headerlink" title="Servlet中的几个方法的作用"></a>Servlet中的几个方法的作用</h2><p>​         1、<strong>pageEncoding=”UTF-8”</strong>的作用是设置JSP编译成Servlet时使用的编码。</p><p>​         2、<u><strong>contentType=”text/html;charset=UTF-8”</strong></u>的作用是指定<u><strong>服务器</strong></u>响应给浏览器的编码。</p><p>​         3、<u><strong>request.setCharacterEncoding(“UTF-8”)</strong></u>的作用是设置对**<u>客户端请求</u>**和数据库取值时的编码，不指定的话使用iso-8859-1。(只解决POST乱码)</p><p>​         4、<u><strong>response.setCharacterEncoding(“UTF-8”)</strong></u>的作用是指定**<u>服务器</u>**响应给浏览器的编码。</p><p>​         5、response.setContentType(“text/html;charset=utf-8”)的作用是指定服务器响应给浏览器的编码。同时，浏览器也是根据这个参数来对其接收到的数据进行重新编码（或者称为解码）。</p><p>对于发送数据，服务器按照response.setCharacterEncoding—contentType—pageEncoding的优先顺序，对要发送的数据进行编码。</p><h3 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h3><p>Get是URL解码方式。默认解码格式是Tomcat8编码格式。所以URL解码是UTF-8，<br>覆盖掉了request容器解码格式<br>Post是实体内容解码方式。默认解码格式是request编码格式。与Tomcat8编码格式无关</p><p>tomcat服务器中Response容器默认以ISO8859-1的编码解析数据，因此如果需要在参数中解析中文，需要设置</p><p>request.setCharacterEncoding(“utf-8”)；</p><p>post得到前台数据：（request容器默认是gbk格式）<br>request.setCharacterEncoding(“utf-8”);<br>System.out.println(request.getParameter(“name”));</p><p>GET得到前台数据：（不需要设置编码格式，默认是按照tomcat服务器的编码格式）<br>System.out.println(request.getParameter(“name”));</p><p>GET POST给前台传数据<br>response.setCharacterEncoding(“utf-8”);<br>response.getWriter().write(“我爱你”);</p><p>==6.==在Servlet处理请求的方式为：以线程的方式</p><p>==7.==在Servlet生命周期中，对应服务阶段的方法是service() ,</p><p>==8.==web.xml中预先对Servlet进行初始化设置的代码如下：</p><init-param><p>​          <param-name>myWord</param-name></p><p>​          <param-value>hello</param-value></p></init-param><p>获取初始化参数的语句是：String myWord=getInitParameter(“myWord”);</p><p><img src="D:/Typora/java/tupian/image-20210417162532940.png" alt="image-20210417162532940"></p><p>==简答题：==</p><p>==1.==什么是Servlet?</p><p>Servlet是Java Servlet的简称，是小服务程序或服务连接器，是用Java编写的服务器程序，是用Java编写的服务器程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。广义的Servlet是指任何实现了这个Servlet接口的类，狭义的Servlet是指Java语言实现的一个接口。</p><p>==2.==GenericServlet和HttpServlet有什么区别？</p><p>​            1.HttpServlet是一个Servlet,继承自GenericServlet,针对于HTTP协议所定制；</p><p>  GenericServlet是一个Servlet,是Servlet接口和ServletConfig接口的实现类。但是是一个抽象类，其中的service()方法为抽象方法。</p><p>​           2.GenericServlet是个抽象类，必须给出子类才能实例化。它给出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说你有可能用非http协议实现它（其实目前Java Servlet还是只有Http一种）。<br>HttpServlet是enericServlet的子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete, doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。</p><p>​            3.HttpServlet是处理Http协议的，对于Http协议来说，HttpServlet比GenericServlet更专业。<br>而GenericServlet是处理一般的Servlet请求的，除了Http请求还有其他的请求，比如说ftp等等。</p><p>==3.==Servlet怎么处理一个请求？</p><p>针对Servlet的每次请求，Web 服务器在调用 service() 方法之前，都会创建 HttpServletRequest 和 HttpServletResponse 对象。其中，HttpServletRequest 对象用于封装 HTTP 请求消息，简称 request 对象。HttpServletResponse 对象用于封装 HTTP 响应消息，简称 response 对象。</p><p>之后调用Servlet中的service()方法，并将请求和响应对象作为参数传入该方法。Servlet方法根据请求方式调用doXXX()方法。</p><p>在doXXX()方法中使用请求对象获取请求信息，响应对象返回响应结果（PrintWrite对象）。</p><p>最后销毁请求和响应对象。</p><h1 id="第六章-会话管理"><a href="#第六章-会话管理" class="headerlink" title="第六章  会话管理"></a>第六章  会话管理</h1><p>Cookie</p><p>•浏览器存储在客户端机器上的头信息称作Cookie，它以“属性名=属性值; …”方式组成文本信息</p><p>ctrl+shift+delete</p><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><p>​    JDK、tomcat、eclipse</p><p>​    Servlet</p><p>​    Servlet 的编写：1、直接实现servlet接口</p><p>​                             2、继承HTTP Servlet</p><h4 id="配置Servlet-的方法："><a href="#配置Servlet-的方法：" class="headerlink" title="配置Servlet 的方法："></a>配置Servlet 的方法：</h4><p>​    方法一：在web.html中进行。涉及到的标签：</p><p>​        <servlet></servlet></p><p>​        <servlet-mapping></servlet-mapping>可以帮助我们通过一个url找到对应的servlet</p><p>​    方法二：通过注解的方式进行配置servlet</p><h4 id="实现servlet的流程："><a href="#实现servlet的流程：" class="headerlink" title="实现servlet的流程："></a>实现servlet的流程：</h4><p>​    收到浏览器的请求  -&gt;  根据url找到对应的servlet （先执行init方法（执行一次），再执行service（可以执行多次）） -&gt; HttpServletRequest/HttpServletResponse -&gt; 实现doGet/doPost方法</p><h4 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h4><p>Request对象对请求进行处理</p><ul><li>getParameter(只能获取一个值，要是要获取多个值就加一个Values)  </li><li>setAttribute  </li><li>setCharacterEncoding(用于设置字符集)</li></ul><p>Response对象返回响应</p><ul><li>getWriter.print(“”);   </li><li>返回流</li><li>返回html页面（动态/静态）</li><li>setContentType(“text/html;charset=utf-8”);//如果字符集是中文，且需要返回HTML页面，则需要写上这行代码</li></ul><h4 id="请求的转发和重定向"><a href="#请求的转发和重定向" class="headerlink" title="请求的转发和重定向"></a>请求的转发和重定向</h4><p>区别主要是：</p><p>　　　　请求转发               　　VS　　　　　　　　　重定向</p><p>　　　　一次请求              　　　　                           　 两次请求</p><p>　　　　速度快                                                       　　　速度较慢</p><p>　　可以进行数据共享                            　　　　　不能进行数据共享</p><p>只显示<strong>第一次</strong>请求的URL         　　　　　　 显示的是<strong>第二次</strong>请求的URL</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>第一步：加载到内存</p><p>第二步：实例化（服务器生成，ｓｅｔｕｐ如果等于0，则为启动的时候进行实例化，如果大于0，则为在浏览器进行第一次请求时实例化）分两步</p><p>第三步：清空（启动的时候／第一请求的时候）</p><p>第四步：初始化、服务、销毁（分为这三种情况，具体要根据实际要求进行判断）</p><h4 id="类层次"><a href="#类层次" class="headerlink" title="类层次"></a>类层次</h4><p>Servlet接口－＞GernericServlet　－＞HTTP Servlet　－＞自定义的servlet</p><h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><p>一、请求转发：</p><p>通过request的getRequest或者是个体parameter、getAttribute获取请求参数或作用域参数</p><p>ServletConfig对象可以获取初始化参数</p><p>ServletContext对象可以获取初始化参数，可以获取作用域中的参数</p><p>定义全局的变量可以共享（但要注意线程的安全问题）</p><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>Cookie   存储到了客户端，注意：大小数量受限（常用于记住我、免密登录）设置周期</p><p>url重写</p><p>隐藏域</p><p>Session 存储位置在服务器的内存中，需要借助cookie</p><p>url重写结合session来实现标识同一用户</p><h2 id="Ch07-过滤器"><a href="#Ch07-过滤器" class="headerlink" title="Ch07   过滤器"></a>Ch07   过滤器</h2><p>过滤器的工作原理</p><p>1、对于客户端的请求进行判断</p><p>2、对于合理的请求，转发给对应的Servlet，不合理的直接返回</p><p>3、在请求到达Servlet之前，对其进行处理</p><p>4、在Servlet处理完数据之后，可以将对应的响应信息返回给Client</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2021/12/05/article-title/"/>
      <url>/2021/12/05/article-title/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次创建博客"><a href="#第一次创建博客" class="headerlink" title="第一次创建博客"></a>第一次创建博客</h1><p>使用nodejs为依托，用hexo创建，部署在github上</p>]]></content>
      
      
      <categories>
          
          <category> 感想记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
